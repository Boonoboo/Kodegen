package dk.cachet.rad.core

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.*
import java.io.File
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.*
import javax.tools.Diagnostic
import io.ktor.application.Application
import io.ktor.client.HttpClient
import javax.lang.model.element.ElementKind

@AutoService(Processor::class)
@SupportedOptions(RadMethodProcessor.KAPT_KOTLIN_GENERATED_OPTION_NAME)
sealed class RadMethodProcessor : AbstractProcessor() {
    companion object {
        const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
    }

    /**
     * Processes all elements annotated with "RadMethod"
     */
    override fun process(annotations: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {
        println("Processing RAD annotations")
        roundEnv.getElementsAnnotatedWith(RadMethod::class.java).forEach {
            val methodElement = it as ExecutableElement

            // If annotated element is not a function, do nothing
            if (methodElement.kind != ElementKind.METHOD) {
                processingEnv.messager.printMessage(
                    Diagnostic.Kind.ERROR,
                    "Error while processing element: $methodElement. Annotation \"RadMethod\" can only be applied to functions"
                )
                return false
            }

            val targetPackage = processingEnv.elementUtils.getPackageOf(methodElement).toString()
            generateServerMethod(methodElement, targetPackage)
            generateClientMethod(methodElement, targetPackage)
        }
        return false
    }

    fun generateServerMethod(methodElement: ExecutableElement, packageOfMethod: String) {
        val targetFunctionName = methodElement.simpleName.toString() + "ServerEndpoint"

        // Error checking
        val generatedSourcesRoot: String = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME].orEmpty()
        if (generatedSourcesRoot.isEmpty()) {
            processingEnv.messager.printMessage(
                Diagnostic.Kind.ERROR,
                "Can't find the target directory for generated Kotlin files."
            )
            return
        }

        // Create extension function "module" for Application
        val moduleFunctionBuilder = FunSpec.builder("module")
            .addModifiers(KModifier.PUBLIC)
            .receiver(Application::class)
            .returns(Unit::class)

        // TODO: Initiate routing
        /*
        val ktorRoutingMember = MemberName("io.ktor.routing", "Application.routing")
        moduleFunctionBuilder
            .addStatement("routing { ... }")
         */

        // TODO: Create endpoint corresponding to the methodElement
        // 1st step: Route on HTTP Method (Only POST for now)
        // .addStatement("post(%functionName { ... }")
        // 2nd step: Get all parameters
        // method.parameters.forEach { ... }
        // .addStatement("val %parameterName = call.parameters["%parameterName"]
        // 3rd step: Call the function
        // .addStatement("val result = %functionName(%parameters))
        // 4th step: Return the result
        // .addStatement("call.respond(result))"
        //methodElement.parameters.forEach {
        //    functionBuilder
        //        .addParameter(it.toString(), it.asType().asTypeName())
        //}

        // Build the file
        val file = File(generatedSourcesRoot)
        file.mkdir()

        FileSpec.builder(packageOfMethod, "$targetFunctionName-AutoGenerated")
            .addFunction(moduleFunctionBuilder.build())
            .build()
            .writeTo(file)
    }

    fun generateClientMethod(methodElement: ExecutableElement, packageOfMethod: String) {
        val targetFunctionName = methodElement.simpleName.toString() + "ClientEndpoint"
        val apiURL = methodElement.simpleName.toString()

        val generatedSourcesRoot: String = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME].orEmpty()
        if(generatedSourcesRoot.isEmpty()) {
            processingEnv.messager.printMessage(
                Diagnostic.Kind.ERROR,
                "Can't find the target directory for generated Kotlin files.")
            return
        }

        // Create client function
        val clientFunctionBuilder = FunSpec.builder(targetFunctionName)
            .addModifiers(KModifier.PUBLIC)
            .addModifiers(KModifier.SUSPEND)
            .returns(methodElement.returnType.asTypeName())

        // Create endpoint corresponding to the methodElement
        // 1st step: Open client
        clientFunctionBuilder.addStatement("val client = %M", HttpClient())

        // 2nd step: Make request
        clientFunctionBuilder.addStatement("val response = client.post(\"$apiURL\"")

        // 3rd step: Close client
        clientFunctionBuilder.addStatement("client.close()")

        // 4th step: Return the result
        clientFunctionBuilder.addStatement("return response")

        // Build the file
        val file = File(generatedSourcesRoot)
        file.mkdir()

        FileSpec.builder(packageOfMethod, "$targetFunctionName-AutoGenerated")
            .addFunction(clientFunctionBuilder.build())
            .build()
            .writeTo(file)
    }
}
